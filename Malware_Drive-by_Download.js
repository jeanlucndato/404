/**
 * Dictionnaire éducatif des types MIME.
 * Permet au navigateur de savoir quel type de fichier il télécharge.
 */
const MIMES_MAP = {
    '.doc': 'application/msword',
    '.pdf': 'application/pdf',
    '.exe': 'application/octet-stream', // Utilisé pour les fichiers exécutables/binaires
    '.txt': 'text/plain'
};

/**
 * Fonction principale pour générer et télécharger le fichier.
 * @param {string} fileName - Le nom du fichier à créer (ex: 'rapport.pdf').
 * @param {string} base64Payload - Les données du fichier encodées en Base64.
 */
function downloadFileFromBase64(fileName, base64Payload) {
    // 1. Validation : Vérifie que les données ne sont pas vides
    if (!fileName || !base64Payload || base64Payload.length === 0) {
        console.error("Erreur éducative: Le nom de fichier ou les données sont manquants.");
        return;
    }

    // 2. Détermination du type MIME (MimeFactory éducative)
    const fileExtension = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
    const mimeType = MIMES_MAP[fileExtension] || 'application/octet-stream';

    console.log(`Fichier à générer: ${fileName} avec le type MIME: ${mimeType}`);

    // --- ÉTAPE DE DÉCODAGE CRITIQUE ---

    // 3. Décodage Base64 vers Chaîne Binaire
    // window.atob (ASCII to Binary) décode la chaîne Base64 en une chaîne binaire (octets).
    const binaryString = window.atob(base64Payload);
    const dataLength = binaryString.length;

    // 4. Conversion de la Chaîne Binaire en Tableau d'Octets (Uint8Array)
    // C'est nécessaire car l'API Blob travaille avec des buffers binaires (mémoire).
    const dataArray = new Uint8Array(dataLength);

    for (let i = 0; i < dataLength; i++) {
        // charCodeAt(i) extrait la valeur numérique (l'octet) de chaque caractère.
        dataArray[i] = binaryString.charCodeAt(i);
    }

    // --- ÉTAPE DE GESTION DE FICHIER LOCALE ---

    // 5. Création de l'objet Blob (Binary Large Object)
    // Le Blob encapsule le tableau d'octets avec son type MIME.
    const fileBlob = new Blob([dataArray.buffer], { type: mimeType });

    // 6. Création d'une URL de référence locale (Object URL)
    // Cette URL est temporaire et pointe vers les données dans la mémoire du navigateur.
    const blobUrl = window.URL.createObjectURL(fileBlob);

    // 7. Déclenchement du Téléchargement via un élément <a> invisible
    const downloadLink = document.createElement('a');

    // Configuration du lien
    downloadLink.href = blobUrl;
    // L'attribut 'download' force le téléchargement et donne le nom au fichier.
    downloadLink.download = fileName;
    downloadLink.style.display = 'none';

    // Ajout, Clic et Suppression immédiate (pour déclencher le téléchargement)
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);

    // 8. Nettoyage de la mémoire
    // Libère la ressource Blob temporaire. Très important pour éviter les fuites de mémoire.
    window.URL.revokeObjectURL(blobUrl);

    console.log(`Téléchargement de '${fileName}' simulé et ressources nettoyées.`);
}

// --- UTILISATION ÉDUCATIVE (Exemple d'Appel) ---
// Note : Le '...' doit être remplacé par une chaîne Base64 réelle.

const FICHIER_MALVEILLANT_B64 = 'TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...'; // Exemple d'un exécutable (TRÈS long)
const DOCUMENT_TEST_B64 = 'JVBERi0xLjQKJcOkwOWE...'; // Exemple d'un PDF ou DOC (doit être un Base64 réel du contenu du fichier)

// Exemple de cas éducatif (remplacez '...' par une chaîne Base64 valide pour tester)
downloadFileFromBase64('test_document.doc', 'TWljcm9zb2Z0IFdvcmQgZG9jdW1lbnQgdGVzdC4=');
// La chaîne ci-dessus décode en: "Microsoft Word document test."